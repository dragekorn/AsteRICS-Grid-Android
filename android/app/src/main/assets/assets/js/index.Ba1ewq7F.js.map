{"version":3,"mappings":"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","names":["DEFAULT_CONFIG","minLevel","maxQueueSize","enableConsole","enablePersistence","_Logger","constructor","context","config","__publicField","this","debug","bind","info","warn","error","getInstance","instances","has","set","get","message","data","log","stackTrace","Error","stack","setLevel","level","getLogs","Object","freeze","logQueue","clearLogs","length","entry","timestamp","Date","now","sanitizeData","shift","push","writeToConsole","persistLog","catch","persistError","prefix","toISOString","getLevelName","consoleMethod","getConsoleMethod","console","seen","WeakSet","JSON","parse","stringify","key","value","add","substring","name","ArrayBuffer","byteLength","sanitizeError","String","Promise","resolve","Map","Logger","createLogger","moduleName","AppErrorCode","AppError","code","details","super","setPrototypeOf","prototype","logger","_ErrorHandler","maxAttempts","baseDelay","maxDelay","backoffMultiplier","failureThreshold","successThreshold","timeout","setupGlobalErrorHandlers","instance","handleError","options","processedError","processError","severity","metadata","addToHistory","shouldReport","reportError","withRetry","operation","maxRetries","defaultRetryConfig","retryDelay","lastError","attempt","result","recordSuccess","recordFailure","isCircuitOpen","INVALID_STATE","originalError","delay","Math","min","pow","extractErrorMessage","sleep","UNKNOWN_ERROR","withCircuitBreaker","circuitName","getErrorHistory","limit","errors","errorHistory","reverse","slice","clearHistory","id","generateErrorId","maxHistorySize","circuit","getOrCreateCircuit","failures","lastFailureTime","successes","defaultCircuitConfig","state","circuits","window","addEventListener","event","preventDefault","reason","errorId","random","toString","ms","setTimeout","errorHandler","enabled","sampleInterval","memoryThreshold","_PerformanceMonitor","startMonitoring","mark","marks","performance","measure","startMark","endMark","startTime","endTime","duration","measurement","measurements","toFixed","getMetrics","memory","getMemoryMetrics","cpu","getCPUMetrics","network","getNetworkMetrics","usedJSHeapSize","totalJSHeapSize","jsHeapSizeLimit","percentUsed","entries","getEntriesByType","usage","throttled","avgDuration","reduce","sum","connection","navigator","online","onLine","effectiveType","downlink","rtt","getMeasurements","getMeasurementsByName","filter","m","getAverageDuration","acc","clear","clearMarks","clearMeasures","clearMark","delete","intervalId","captureMetrics","setInterval","interval","stopMonitoring","clearInterval","metrics","metricsHistory","checkThresholds","memoryPercent","alert","type","threshold","triggerAlert","alertCallback","getMetricsHistory","history","generateReport","currentMetrics","report","sort","a","b","forEach","i","performanceMonitor","TTSService","play","audioContext","AudioContext","resume","audioBuffer","decodeAudioData","audioData","source","createBufferSource","buffer","loop","gainNode","createGain","gain","volume","connect","destination","reject","onended","disconnect","onEnd","start","onError","errorCallback","handledError","stop","close","then","setVoice","voiceId","getAvailableVoices","find","v","currentVoice","getCurrentVoice","validateOptions","text","trim","voice","rate","clamp","pitch","language","max","generateRequestId","ensureInitialized","isInitialized","_TTSServiceFactory","createInstance","ServerTTSService","__vitePreload","async","import","__VITE_PRELOAD__","service","initialize","MockTTSService","reset","cleanup","TTSServiceFactory","_NLPClient","serverUrl","retryAttempts","healthCheck","response","fetch","method","signal","AbortSignal","ok","status","json","buildSentence","words","res","headers","body","sentence","generateSpeech","arrayBuffer","audioSize","setServerUrl","url","nlpClient","testTTS","appDiv","document","getElementById","innerHTML","serverUrlInput","setServerBtn","testServerBtn","wordsInput","speakBtn","statusDiv","logsDiv","addLog","msg","toLocaleTimeString","textContent","scrollTop","scrollHeight","updateStatus","isError","style","background","e","filename","lineno","statusText","model","err","tts","split","w","join","synthesize","userAgent","location","href","readyState"],"ignoreList":[],"sources":["../../../src/js/util/Logger.ts","../../../src/types/global.ts","../../../src/js/util/ErrorHandler.ts","../../../src/js/util/PerformanceMonitor.ts","../../../src/js/service/tts/TTSService.ts","../../../src/js/service/api/NLPClient.ts","../../../src/js/test-tts.ts"],"sourcesContent":["/**\r\n * Structured logging service for AsTeRICS-Grid Android.\r\n * \r\n * Features:\r\n * - Configurable log levels\r\n * - Contextual logging\r\n * - Structured data support\r\n * - Performance-optimized (zero-cost in production when disabled)\r\n * - Memory-safe circular reference handling\r\n * - Thread-safe log queue\r\n * \r\n * @example\r\n * ```typescript\r\n * const logger = Logger.getInstance('TTSService');\r\n * logger.info('Synthesis started', { requestId: '123', text: 'Hello' });\r\n * logger.error('Synthesis failed', new Error('WASM init failed'));\r\n * ```\r\n */\r\n\r\nimport type { ILogger, ILogEntry, LogLevel } from '@/types/global';\r\n\r\n/**\r\n * Configuration for logger instance.\r\n */\r\ninterface ILoggerConfig {\r\n  readonly minLevel: LogLevel;\r\n  readonly maxQueueSize: number;\r\n  readonly enableConsole: boolean;\r\n  readonly enablePersistence: boolean;\r\n}\r\n\r\n/**\r\n * Default logger configuration.\r\n */\r\nconst DEFAULT_CONFIG: ILoggerConfig = {\r\n  minLevel: __DEV__ ? 0 /* DEBUG */ : 1 /* INFO */,\r\n  maxQueueSize: 1000,\r\n  enableConsole: true,\r\n  enablePersistence: false,\r\n} as const;\r\n\r\n/**\r\n * Singleton logger implementation with structured logging.\r\n * Thread-safe and memory-efficient.\r\n */\r\nexport class Logger implements ILogger {\r\n  private static readonly instances = new Map<string, Logger>();\r\n  private readonly logQueue: ILogEntry[] = [];\r\n  private config: ILoggerConfig;\r\n\r\n  /**\r\n   * Private constructor to enforce singleton pattern per context.\r\n   * \r\n   * @param context - Logger context (e.g., service name)\r\n   * @param config - Logger configuration\r\n   */\r\n  private constructor(\r\n    private readonly context: string,\r\n    config: Partial<ILoggerConfig> = {}\r\n  ) {\r\n    this.config = { ...DEFAULT_CONFIG, ...config };\r\n    \r\n    // Bind methods to preserve context\r\n    this.debug = this.debug.bind(this);\r\n    this.info = this.info.bind(this);\r\n    this.warn = this.warn.bind(this);\r\n    this.error = this.error.bind(this);\r\n  }\r\n\r\n  /**\r\n   * Gets or creates a logger instance for the given context.\r\n   * \r\n   * @param context - Logger context identifier\r\n   * @param config - Optional configuration overrides\r\n   * @returns Logger instance\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * const logger = Logger.getInstance('MyService');\r\n   * ```\r\n   */\r\n  public static getInstance(\r\n    context: string,\r\n    config?: Partial<ILoggerConfig>\r\n  ): Logger {\r\n    if (!Logger.instances.has(context)) {\r\n      Logger.instances.set(context, new Logger(context, config));\r\n    }\r\n    return Logger.instances.get(context)!;\r\n  }\r\n\r\n  /**\r\n   * Logs a debug message.\r\n   * Only logged if level >= DEBUG.\r\n   * \r\n   * @param message - Log message\r\n   * @param data - Optional structured data\r\n   */\r\n  public debug(message: string, data?: unknown): void {\r\n    this.log(0 /* DEBUG */, message, data);\r\n  }\r\n\r\n  /**\r\n   * Logs an info message.\r\n   * Only logged if level >= INFO.\r\n   * \r\n   * @param message - Log message\r\n   * @param data - Optional structured data\r\n   */\r\n  public info(message: string, data?: unknown): void {\r\n    this.log(1 /* INFO */, message, data);\r\n  }\r\n\r\n  /**\r\n   * Logs a warning message.\r\n   * Only logged if level >= WARN.\r\n   * \r\n   * @param message - Log message\r\n   * @param data - Optional structured data\r\n   */\r\n  public warn(message: string, data?: unknown): void {\r\n    this.log(2 /* WARN */, message, data);\r\n  }\r\n\r\n  /**\r\n   * Logs an error message with stack trace.\r\n   * Always logged regardless of level.\r\n   * \r\n   * @param message - Log message\r\n   * @param error - Optional error object or data\r\n   */\r\n  public error(message: string, error?: Error | unknown): void {\r\n    const stackTrace = error instanceof Error ? error.stack : undefined;\r\n    this.log(3 /* ERROR */, message, error, stackTrace);\r\n  }\r\n\r\n  /**\r\n   * Sets the minimum log level.\r\n   * \r\n   * @param level - New minimum log level\r\n   */\r\n  public setLevel(level: LogLevel): void {\r\n    this.config = { ...this.config, minLevel: level };\r\n  }\r\n\r\n  /**\r\n   * Gets all log entries from the queue.\r\n   * \r\n   * @returns Readonly array of log entries\r\n   */\r\n  public getLogs(): readonly ILogEntry[] {\r\n    return Object.freeze([...this.logQueue]);\r\n  }\r\n\r\n  /**\r\n   * Clears the log queue.\r\n   * Useful for memory management in long-running sessions.\r\n   */\r\n  public clearLogs(): void {\r\n    this.logQueue.length = 0;\r\n  }\r\n\r\n  /**\r\n   * Core logging method with level filtering and queue management.\r\n   * \r\n   * @param level - Log level\r\n   * @param message - Log message\r\n   * @param data - Optional data payload\r\n   * @param stackTrace - Optional stack trace\r\n   */\r\n  private log(\r\n    level: LogLevel,\r\n    message: string,\r\n    data?: unknown,\r\n    stackTrace?: string\r\n  ): void {\r\n    // Early return if below minimum level (zero-cost when disabled)\r\n    if (level < this.config.minLevel) {\r\n      return;\r\n    }\r\n\r\n    const entry: ILogEntry = Object.freeze({\r\n      level,\r\n      message,\r\n      timestamp: Date.now(),\r\n      context: this.context,\r\n      data: this.sanitizeData(data),\r\n      stackTrace,\r\n    });\r\n\r\n    // Add to queue with overflow protection\r\n    if (this.logQueue.length >= this.config.maxQueueSize) {\r\n      this.logQueue.shift(); // Remove oldest entry\r\n    }\r\n    this.logQueue.push(entry);\r\n\r\n    // Console output (if enabled)\r\n    if (this.config.enableConsole) {\r\n      this.writeToConsole(entry);\r\n    }\r\n\r\n    // Persistence (if enabled)\r\n    if (this.config.enablePersistence) {\r\n      this.persistLog(entry).catch((persistError) => {\r\n        // Fallback to console on persistence failure\r\n        console.error('[Logger] Failed to persist log:', persistError);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Writes log entry to console with appropriate formatting.\r\n   * \r\n   * @param entry - Log entry to write\r\n   */\r\n  private writeToConsole(entry: ILogEntry): void {\r\n    const timestamp = new Date(entry.timestamp).toISOString();\r\n    const prefix = `[${timestamp}] [${this.getLevelName(entry.level)}] [${entry.context}]`;\r\n    \r\n    const consoleMethod = this.getConsoleMethod(entry.level);\r\n    \r\n    if (entry.data !== undefined || entry.stackTrace !== undefined) {\r\n      consoleMethod(prefix, entry.message, {\r\n        data: entry.data,\r\n        stack: entry.stackTrace,\r\n      });\r\n    } else {\r\n      consoleMethod(prefix, entry.message);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets console method for log level.\r\n   * \r\n   * @param level - Log level\r\n   * @returns Console method\r\n   */\r\n  private getConsoleMethod(level: LogLevel): Console['log'] {\r\n    switch (level) {\r\n      case 0: /* DEBUG */\r\n        return console.log;\r\n      case 1: /* INFO */\r\n        return console.info;\r\n      case 2: /* WARN */\r\n        return console.warn;\r\n      case 3: /* ERROR */\r\n        return console.error;\r\n      default:\r\n        return console.log;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets human-readable level name.\r\n   * \r\n   * @param level - Log level\r\n   * @returns Level name\r\n   */\r\n  private getLevelName(level: LogLevel): string {\r\n    const names = ['DEBUG', 'INFO', 'WARN', 'ERROR'] as const;\r\n    return names[level] ?? 'UNKNOWN';\r\n  }\r\n\r\n  /**\r\n   * Sanitizes data for logging, handling circular references and large objects.\r\n   * \r\n   * @param data - Data to sanitize\r\n   * @returns Sanitized data safe for logging\r\n   */\r\n  private sanitizeData(data: unknown): unknown {\r\n    if (data === null || data === undefined) {\r\n      return data;\r\n    }\r\n\r\n    try {\r\n      // Handle circular references with replacer\r\n      const seen = new WeakSet<object>();\r\n      \r\n      return JSON.parse(\r\n        JSON.stringify(data, (key, value: unknown) => {\r\n          // Handle circular references\r\n          if (typeof value === 'object' && value !== null) {\r\n            if (seen.has(value)) {\r\n              return '[Circular Reference]';\r\n            }\r\n            seen.add(value);\r\n          }\r\n\r\n          // Truncate long strings\r\n          if (typeof value === 'string' && value.length > 1000) {\r\n            return `${value.substring(0, 1000)}... [truncated]`;\r\n          }\r\n\r\n          // Handle special objects\r\n          if (value instanceof Error) {\r\n            return {\r\n              name: value.name,\r\n              message: value.message,\r\n              stack: value.stack,\r\n            };\r\n          }\r\n\r\n          if (value instanceof ArrayBuffer) {\r\n            return `[ArrayBuffer ${value.byteLength} bytes]`;\r\n          }\r\n\r\n          return value;\r\n        })\r\n      );\r\n    } catch (sanitizeError) {\r\n      // Fallback if sanitization fails\r\n      return `[Unsanitizable data: ${String(sanitizeError)}]`;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Persists log entry to storage (IndexedDB).\r\n   * Non-blocking operation with error handling.\r\n   * \r\n   * @param entry - Log entry to persist\r\n   * @returns Promise that resolves when persistence completes\r\n   */\r\n  private async persistLog(entry: ILogEntry): Promise<void> {\r\n    // Implementation will be added in Phase 3 (Storage)\r\n    // For now, this is a placeholder\r\n    return Promise.resolve();\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a scoped logger for a specific module.\r\n * Convenience function for common usage pattern.\r\n * \r\n * @param moduleName - Name of the module\r\n * @returns Configured logger instance\r\n * \r\n * @example\r\n * ```typescript\r\n * const logger = createLogger('TTSService');\r\n * logger.info('Service initialized');\r\n * ```\r\n */\r\nexport function createLogger(moduleName: string): ILogger {\r\n  return Logger.getInstance(moduleName);\r\n}\r\n\r\n// Export singleton instance for global logging\r\nexport const globalLogger = Logger.getInstance('Global');","/**\n * Global type definitions - converted from .d.ts\n */\n\n/* ==================== Application Types ==================== */\n\nexport interface IAppConfig {\n  readonly version: string;\n  readonly buildTime: string;\n  readonly environment: 'development' | 'production';\n  readonly tts: ITTSConfig;\n  readonly storage: IStorageConfig;\n  readonly performance: IPerformanceConfig;\n}\n\nexport interface ITTSConfig {\n  readonly enabled: boolean;\n  readonly defaultVoice: string;\n  readonly fallbackVoice: string;\n  readonly sampleRate: number;\n  readonly maxConcurrentRequests: number;\n  readonly synthesisTimeout: number;\n  readonly cacheEnabled: boolean;\n  readonly cacheSizeLimit: number;\n}\n\nexport interface IStorageConfig {\n  readonly indexedDbName: string;\n  readonly indexedDbVersion: number;\n  readonly cacheQuota: number;\n  readonly persistentStorage: boolean;\n}\n\nexport interface IPerformanceConfig {\n  readonly enabled: boolean;\n  readonly metricsInterval: number;\n  readonly memoryWarningThreshold: number;\n  readonly cpuWarningThreshold: number;\n}\n\n/* ==================== TTS Service Types ==================== */\n\nexport interface ITTSRequest {\n  readonly id: string;\n  readonly text: string;\n  readonly voice: string;\n  readonly rate: number;\n  readonly pitch: number;\n  readonly volume: number;\n  readonly language: string;\n  readonly timestamp: number;\n}\n\nexport interface ITTSResult {\n  readonly requestId: string;\n  readonly audioData: ArrayBuffer;\n  readonly duration: number;\n  readonly sampleRate: number;\n  readonly channels: number;\n  readonly synthesisTime: number;\n}\n\nexport interface ITTSError {\n  readonly code: TTSErrorCode;\n  readonly message: string;\n  readonly requestId: string;\n  readonly timestamp: number;\n  readonly details?: unknown;\n}\n\nexport enum TTSErrorCode {\n  SYNTHESIS_FAILED = 'SYNTHESIS_FAILED',\n  VOICE_NOT_FOUND = 'VOICE_NOT_FOUND',\n  INVALID_INPUT = 'INVALID_INPUT',\n  TIMEOUT = 'TIMEOUT',\n  MEMORY_ERROR = 'MEMORY_ERROR',\n  WASM_INIT_FAILED = 'WASM_INIT_FAILED',\n  AUDIO_PLAYBACK_FAILED = 'AUDIO_PLAYBACK_FAILED',\n  UNKNOWN_ERROR = 'UNKNOWN_ERROR',\n}\n\nexport interface ITTSStatus {\n  readonly initialized: boolean;\n  readonly activeRequests: number;\n  readonly queuedRequests: number;\n  readonly availableVoices: readonly string[];\n  readonly memoryUsage: number;\n  readonly lastError: ITTSError | null;\n}\n\nexport interface IVoiceModel {\n  readonly id: string;\n  readonly name: string;\n  readonly language: string;\n  readonly gender: 'male' | 'female' | 'neutral';\n  readonly sampleRate: number;\n  readonly modelSize: number;\n  readonly quality: 'low' | 'medium' | 'high';\n  readonly loaded: boolean;\n}\n\n/* ==================== Error Handling Types ==================== */\n\nexport enum AppErrorCode {\n  INITIALIZATION_FAILED = 'INITIALIZATION_FAILED',\n  CONFIGURATION_ERROR = 'CONFIGURATION_ERROR',\n  STORAGE_ERROR = 'STORAGE_ERROR',\n  NETWORK_ERROR = 'NETWORK_ERROR',\n  PERMISSION_DENIED = 'PERMISSION_DENIED',\n  RESOURCE_NOT_FOUND = 'RESOURCE_NOT_FOUND',\n  INVALID_STATE = 'INVALID_STATE',\n  UNKNOWN_ERROR = 'UNKNOWN_ERROR',\n}\n\nexport class AppError extends Error {\n  constructor(\n    public readonly code: AppErrorCode,\n    message: string,\n    public readonly details?: unknown,\n    public readonly timestamp: number = Date.now()\n  ) {\n    super(message);\n    this.name = 'AppError';\n    Object.setPrototypeOf(this, AppError.prototype);\n  }\n}\n\n/* ==================== Performance Monitoring Types ==================== */\n\nexport interface IPerformanceMetrics {\n  readonly timestamp: number;\n  readonly memory: IMemoryMetrics;\n  readonly cpu: ICPUMetrics;\n  readonly network: INetworkMetrics;\n}\n\nexport interface IMemoryMetrics {\n  readonly usedJSHeapSize: number;\n  readonly totalJSHeapSize: number;\n  readonly jsHeapSizeLimit: number;\n  readonly percentUsed: number;\n}\n\nexport interface ICPUMetrics {\n  readonly usage: number;\n  readonly throttled: boolean;\n}\n\nexport interface INetworkMetrics {\n  readonly online: boolean;\n  readonly effectiveType: string;\n  readonly downlink: number;\n  readonly rtt: number;\n}\n\n/* ==================== Logger Types ==================== */\n\nexport enum LogLevel {\n  DEBUG = 0,\n  INFO = 1,\n  WARN = 2,\n  ERROR = 3,\n}\n\nexport interface ILogEntry {\n  readonly level: LogLevel;\n  readonly message: string;\n  readonly timestamp: number;\n  readonly context?: string;\n  readonly data?: unknown;\n  readonly stackTrace?: string;\n}\n\nexport interface ILogger {\n  debug(message: string, data?: unknown): void;\n  info(message: string, data?: unknown): void;\n  warn(message: string, data?: unknown): void;\n  error(message: string, error?: Error | unknown): void;\n  setLevel(level: LogLevel): void;\n}\n\n/* ==================== Storage Types ==================== */\n\nexport interface IStorageItem<T> {\n  readonly key: string;\n  readonly value: T;\n  readonly timestamp: number;\n  readonly expiresAt: number | null;\n}\n\nexport type StorageResult<T> =\n  | { readonly success: true; readonly data: T }\n  | { readonly success: false; readonly error: Error };\n\nexport interface ICacheEntry {\n  readonly id: string;\n  readonly text: string;\n  readonly voice: string;\n  readonly audioData: ArrayBuffer;\n  readonly size: number;\n  readonly createdAt: number;\n  readonly lastAccessedAt: number;\n  readonly accessCount: number;\n}\n","/**\r\n * Centralized error handling and recovery service.\r\n * \r\n * Features:\r\n * - Structured error classification\r\n * - Automatic retry logic for transient failures\r\n * - Circuit breaker pattern for failing services\r\n * - Error reporting and aggregation\r\n * - Memory-safe error storage\r\n * \r\n * @example\r\n * ```typescript\r\n * const errorHandler = ErrorHandler.getInstance();\r\n * \r\n * try {\r\n *   await riskyOperation();\r\n * } catch (error) {\r\n *   errorHandler.handleError(error, { context: 'TTSService' });\r\n * }\r\n * ```\r\n */\r\n\r\nimport { AppError, AppErrorCode } from '@/types/global';\r\nimport { createLogger } from './Logger';\r\n\r\nconst logger = createLogger('ErrorHandler');\r\n\r\n/**\r\n * Error severity levels for prioritization.\r\n */\r\nexport enum ErrorSeverity {\r\n  LOW = 'LOW',\r\n  MEDIUM = 'MEDIUM',\r\n  HIGH = 'HIGH',\r\n  CRITICAL = 'CRITICAL',\r\n}\r\n\r\n/**\r\n * Error handling options.\r\n */\r\nexport interface IErrorHandlingOptions {\r\n  readonly context?: string;\r\n  readonly severity?: ErrorSeverity;\r\n  readonly shouldReport?: boolean;\r\n  readonly shouldRetry?: boolean;\r\n  readonly maxRetries?: number;\r\n  readonly retryDelay?: number;\r\n  readonly metadata?: Record<string, unknown>;\r\n}\r\n\r\n/**\r\n * Processed error information.\r\n */\r\nexport interface IProcessedError {\r\n  readonly id: string;\r\n  readonly code: AppErrorCode;\r\n  readonly message: string;\r\n  readonly severity: ErrorSeverity;\r\n  readonly timestamp: number;\r\n  readonly context?: string;\r\n  readonly stackTrace?: string;\r\n  readonly metadata?: Record<string, unknown>;\r\n  readonly originalError: unknown;\r\n}\r\n\r\n/**\r\n * Retry configuration for transient errors.\r\n */\r\ninterface IRetryConfig {\r\n  readonly maxAttempts: number;\r\n  readonly baseDelay: number;\r\n  readonly maxDelay: number;\r\n  readonly backoffMultiplier: number;\r\n}\r\n\r\n/**\r\n * Circuit breaker state.\r\n */\r\nenum CircuitState {\r\n  CLOSED = 'CLOSED',     // Normal operation\r\n  OPEN = 'OPEN',         // Failing, reject immediately\r\n  HALF_OPEN = 'HALF_OPEN', // Testing if service recovered\r\n}\r\n\r\n/**\r\n * Circuit breaker configuration.\r\n */\r\ninterface ICircuitBreakerConfig {\r\n  readonly failureThreshold: number;\r\n  readonly successThreshold: number;\r\n  readonly timeout: number;\r\n}\r\n\r\n/**\r\n * Centralized error handler with retry and circuit breaker patterns.\r\n * Singleton instance ensures consistent error handling across the application.\r\n */\r\nexport class ErrorHandler {\r\n  private static instance: ErrorHandler | null = null;\r\n  \r\n  private readonly errorHistory: IProcessedError[] = [];\r\n  private readonly maxHistorySize = 100;\r\n  \r\n  private readonly circuits = new Map<string, {\r\n    state: CircuitState;\r\n    failures: number;\r\n    successes: number;\r\n    lastFailureTime: number;\r\n  }>();\r\n\r\n  private readonly defaultRetryConfig: IRetryConfig = {\r\n    maxAttempts: 3,\r\n    baseDelay: 1000,\r\n    maxDelay: 10000,\r\n    backoffMultiplier: 2,\r\n  } as const;\r\n\r\n  private readonly defaultCircuitConfig: ICircuitBreakerConfig = {\r\n    failureThreshold: 5,\r\n    successThreshold: 2,\r\n    timeout: 60000, // 1 minute\r\n  } as const;\r\n\r\n  /**\r\n   * Private constructor to enforce singleton pattern.\r\n   */\r\n  private constructor() {\r\n    this.setupGlobalErrorHandlers();\r\n  }\r\n\r\n  /**\r\n   * Gets the singleton instance of ErrorHandler.\r\n   * \r\n   * @returns ErrorHandler instance\r\n   */\r\n  public static getInstance(): ErrorHandler {\r\n    if (ErrorHandler.instance === null) {\r\n      ErrorHandler.instance = new ErrorHandler();\r\n    }\r\n    return ErrorHandler.instance;\r\n  }\r\n\r\n  /**\r\n   * Handles an error with optional retry and reporting.\r\n   * \r\n   * @param error - Error to handle\r\n   * @param options - Error handling options\r\n   * @returns Processed error information\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * errorHandler.handleError(error, {\r\n   *   context: 'TTSService',\r\n   *   severity: ErrorSeverity.HIGH,\r\n   *   shouldRetry: true,\r\n   *   maxRetries: 3\r\n   * });\r\n   * ```\r\n   */\r\n  public handleError(\r\n    error: unknown,\r\n    options: IErrorHandlingOptions = {}\r\n  ): IProcessedError {\r\n    const processedError = this.processError(error, options);\r\n    \r\n    // Log the error\r\n    logger.error(processedError.message, {\r\n      code: processedError.code,\r\n      severity: processedError.severity,\r\n      context: processedError.context,\r\n      metadata: processedError.metadata,\r\n    });\r\n\r\n    // Store in history\r\n    this.addToHistory(processedError);\r\n\r\n    // Report to external service if needed\r\n    if (options.shouldReport === true) {\r\n      this.reportError(processedError).catch((reportError) => {\r\n        logger.warn('Failed to report error', reportError);\r\n      });\r\n    }\r\n\r\n    return processedError;\r\n  }\r\n\r\n  /**\r\n   * Wraps an async operation with retry logic.\r\n   * \r\n   * @param operation - Async operation to execute\r\n   * @param options - Error handling options\r\n   * @returns Promise with operation result\r\n   * \r\n   * @throws {AppError} If all retry attempts fail\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * const result = await errorHandler.withRetry(\r\n   *   () => fetchData(),\r\n   *   { maxRetries: 3, retryDelay: 1000 }\r\n   * );\r\n   * ```\r\n   */\r\n  public async withRetry<T>(\r\n    operation: () => Promise<T>,\r\n    options: IErrorHandlingOptions = {}\r\n  ): Promise<T> {\r\n    const maxRetries = options.maxRetries ?? this.defaultRetryConfig.maxAttempts;\r\n    const baseDelay = options.retryDelay ?? this.defaultRetryConfig.baseDelay;\r\n\r\n    let lastError: unknown;\r\n\r\n    for (let attempt = 0; attempt < maxRetries; attempt++) {\r\n      try {\r\n        const result = await operation();\r\n        \r\n        // Reset circuit on success\r\n        if (options.context !== undefined) {\r\n          this.recordSuccess(options.context);\r\n        }\r\n        \r\n        return result;\r\n      } catch (error) {\r\n        lastError = error;\r\n        \r\n        // Record failure in circuit\r\n        if (options.context !== undefined) {\r\n          this.recordFailure(options.context);\r\n        }\r\n\r\n        // Don't retry if circuit is open\r\n        if (options.context !== undefined && this.isCircuitOpen(options.context)) {\r\n          throw new AppError(\r\n            AppErrorCode.INVALID_STATE,\r\n            `Circuit breaker open for ${options.context}`,\r\n            { originalError: error }\r\n          );\r\n        }\r\n\r\n        // Don't retry on last attempt\r\n        if (attempt === maxRetries - 1) {\r\n          break;\r\n        }\r\n\r\n        // Calculate exponential backoff delay\r\n        const delay = Math.min(\r\n          baseDelay * Math.pow(this.defaultRetryConfig.backoffMultiplier, attempt),\r\n          this.defaultRetryConfig.maxDelay\r\n        );\r\n\r\n        logger.warn(`Retry attempt ${attempt + 1}/${maxRetries} after ${delay}ms`, {\r\n          context: options.context,\r\n          error: this.extractErrorMessage(error),\r\n        });\r\n\r\n        await this.sleep(delay);\r\n      }\r\n    }\r\n\r\n    // All retries failed\r\n    throw new AppError(\r\n      AppErrorCode.UNKNOWN_ERROR,\r\n      `Operation failed after ${maxRetries} attempts`,\r\n      { lastError }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Executes operation with circuit breaker pattern.\r\n   * \r\n   * @param circuitName - Unique circuit identifier\r\n   * @param operation - Operation to execute\r\n   * @returns Promise with operation result\r\n   * \r\n   * @throws {AppError} If circuit is open\r\n   */\r\n  public async withCircuitBreaker<T>(\r\n    circuitName: string,\r\n    operation: () => Promise<T>\r\n  ): Promise<T> {\r\n    if (this.isCircuitOpen(circuitName)) {\r\n      throw new AppError(\r\n        AppErrorCode.INVALID_STATE,\r\n        `Circuit breaker is open for ${circuitName}`,\r\n        { circuitName }\r\n      );\r\n    }\r\n\r\n    try {\r\n      const result = await operation();\r\n      this.recordSuccess(circuitName);\r\n      return result;\r\n    } catch (error) {\r\n      this.recordFailure(circuitName);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets recent error history.\r\n   * \r\n   * @param limit - Maximum number of errors to return\r\n   * @returns Array of recent errors\r\n   */\r\n  public getErrorHistory(limit?: number): readonly IProcessedError[] {\r\n    const errors = [...this.errorHistory].reverse();\r\n    return Object.freeze(limit !== undefined ? errors.slice(0, limit) : errors);\r\n  }\r\n\r\n  /**\r\n   * Clears error history.\r\n   * Useful for memory management.\r\n   */\r\n  public clearHistory(): void {\r\n    this.errorHistory.length = 0;\r\n  }\r\n\r\n  /**\r\n   * Processes raw error into structured format.\r\n   * \r\n   * @param error - Raw error\r\n   * @param options - Processing options\r\n   * @returns Processed error\r\n   */\r\n  private processError(\r\n    error: unknown,\r\n    options: IErrorHandlingOptions\r\n  ): IProcessedError {\r\n    const id = this.generateErrorId();\r\n    const timestamp = Date.now();\r\n    \r\n    if (error instanceof AppError) {\r\n      return {\r\n        id,\r\n        code: error.code,\r\n        message: error.message,\r\n        severity: options.severity ?? ErrorSeverity.MEDIUM,\r\n        timestamp,\r\n        context: options.context,\r\n        stackTrace: error.stack,\r\n        metadata: options.metadata,\r\n        originalError: error,\r\n      };\r\n    }\r\n\r\n    if (error instanceof Error) {\r\n      return {\r\n        id,\r\n        code: AppErrorCode.UNKNOWN_ERROR,\r\n        message: error.message,\r\n        severity: options.severity ?? ErrorSeverity.MEDIUM,\r\n        timestamp,\r\n        context: options.context,\r\n        stackTrace: error.stack,\r\n        metadata: options.metadata,\r\n        originalError: error,\r\n      };\r\n    }\r\n\r\n    // Handle non-Error objects\r\n    return {\r\n      id,\r\n      code: AppErrorCode.UNKNOWN_ERROR,\r\n      message: String(error),\r\n      severity: options.severity ?? ErrorSeverity.LOW,\r\n      timestamp,\r\n      context: options.context,\r\n      metadata: options.metadata,\r\n      originalError: error,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Adds error to history with overflow protection.\r\n   * \r\n   * @param error - Processed error\r\n   */\r\n  private addToHistory(error: IProcessedError): void {\r\n    if (this.errorHistory.length >= this.maxHistorySize) {\r\n      this.errorHistory.shift();\r\n    }\r\n    this.errorHistory.push(error);\r\n  }\r\n\r\n  /**\r\n   * Records a failure for circuit breaker.\r\n   * \r\n   * @param circuitName - Circuit identifier\r\n   */\r\n  private recordFailure(circuitName: string): void {\r\n    const circuit = this.getOrCreateCircuit(circuitName);\r\n    circuit.failures++;\r\n    circuit.lastFailureTime = Date.now();\r\n    circuit.successes = 0;\r\n\r\n    if (circuit.failures >= this.defaultCircuitConfig.failureThreshold) {\r\n      circuit.state = CircuitState.OPEN;\r\n      logger.warn(`Circuit breaker opened for ${circuitName}`, {\r\n        failures: circuit.failures,\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Records a success for circuit breaker.\r\n   * \r\n   * @param circuitName - Circuit identifier\r\n   */\r\n  private recordSuccess(circuitName: string): void {\r\n    const circuit = this.getOrCreateCircuit(circuitName);\r\n    \r\n    if (circuit.state === CircuitState.HALF_OPEN) {\r\n      circuit.successes++;\r\n      \r\n      if (circuit.successes >= this.defaultCircuitConfig.successThreshold) {\r\n        circuit.state = CircuitState.CLOSED;\r\n        circuit.failures = 0;\r\n        circuit.successes = 0;\r\n        logger.info(`Circuit breaker closed for ${circuitName}`);\r\n      }\r\n    } else if (circuit.state === CircuitState.CLOSED) {\r\n      circuit.failures = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if circuit breaker is open.\r\n   * \r\n   * @param circuitName - Circuit identifier\r\n   * @returns True if circuit is open\r\n   */\r\n  private isCircuitOpen(circuitName: string): boolean {\r\n    const circuit = this.circuits.get(circuitName);\r\n    \r\n    if (circuit === undefined) {\r\n      return false;\r\n    }\r\n\r\n    if (circuit.state === CircuitState.OPEN) {\r\n      const timeSinceLastFailure = Date.now() - circuit.lastFailureTime;\r\n      \r\n      if (timeSinceLastFailure >= this.defaultCircuitConfig.timeout) {\r\n        circuit.state = CircuitState.HALF_OPEN;\r\n        logger.info(`Circuit breaker half-open for ${circuitName}`);\r\n        return false;\r\n      }\r\n      \r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Gets or creates circuit state.\r\n   * \r\n   * @param circuitName - Circuit identifier\r\n   * @returns Circuit state\r\n   */\r\n  private getOrCreateCircuit(circuitName: string): {\r\n    state: CircuitState;\r\n    failures: number;\r\n    successes: number;\r\n    lastFailureTime: number;\r\n  } {\r\n    if (!this.circuits.has(circuitName)) {\r\n      this.circuits.set(circuitName, {\r\n        state: CircuitState.CLOSED,\r\n        failures: 0,\r\n        successes: 0,\r\n        lastFailureTime: 0,\r\n      });\r\n    }\r\n    return this.circuits.get(circuitName)!;\r\n  }\r\n\r\n  /**\r\n   * Sets up global error handlers for unhandled errors.\r\n   */\r\n  private setupGlobalErrorHandlers(): void {\r\n    // Unhandled promise rejections\r\n    window.addEventListener('unhandledrejection', (event) => {\r\n      event.preventDefault();\r\n      this.handleError(event.reason, {\r\n        context: 'UnhandledRejection',\r\n        severity: ErrorSeverity.HIGH,\r\n        shouldReport: true,\r\n      });\r\n    });\r\n\r\n    // Global errors\r\n    window.addEventListener('error', (event) => {\r\n      this.handleError(event.error ?? event.message, {\r\n        context: 'GlobalError',\r\n        severity: ErrorSeverity.HIGH,\r\n        shouldReport: true,\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Reports error to external service.\r\n   * Placeholder for future implementation.\r\n   * \r\n   * @param error - Processed error\r\n   * @returns Promise that resolves when reporting completes\r\n   */\r\n  private async reportError(error: IProcessedError): Promise<void> {\r\n    // Implementation will be added when error reporting service is configured\r\n    logger.debug('Error reported', { errorId: error.id });\r\n    return Promise.resolve();\r\n  }\r\n\r\n  /**\r\n   * Extracts error message from unknown error.\r\n   * \r\n   * @param error - Unknown error\r\n   * @returns Error message\r\n   */\r\n  private extractErrorMessage(error: unknown): string {\r\n    if (error instanceof Error) {\r\n      return error.message;\r\n    }\r\n    return String(error);\r\n  }\r\n\r\n  /**\r\n   * Generates unique error ID.\r\n   * \r\n   * @returns Unique error identifier\r\n   */\r\n  private generateErrorId(): string {\r\n    return `err_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n  }\r\n\r\n  /**\r\n   * Sleep utility for retry delays.\r\n   * \r\n   * @param ms - Milliseconds to sleep\r\n   * @returns Promise that resolves after delay\r\n   */\r\n  private sleep(ms: number): Promise<void> {\r\n    return new Promise((resolve) => setTimeout(resolve, ms));\r\n  }\r\n}\r\n\r\n/**\r\n * Global error handler instance.\r\n * Use this for consistent error handling across the application.\r\n */\r\nexport const errorHandler = ErrorHandler.getInstance();","/**\r\n * Performance monitoring and resource tracking service.\r\n * \r\n * Features:\r\n * - Memory usage monitoring\r\n * - CPU usage estimation\r\n * - Network metrics\r\n * - Custom performance marks\r\n * - Automatic threshold alerts\r\n * - Zero-overhead when disabled\r\n * \r\n * Target metrics:\r\n * - Memory: < 150MB peak usage\r\n * - CPU: < 70% average utilization\r\n * - FPS: > 55 for UI interactions\r\n * \r\n * @example\r\n * ```typescript\r\n * const monitor = PerformanceMonitor.getInstance();\r\n * \r\n * // Measure operation\r\n * monitor.mark('tts-synthesis-start');\r\n * await synthesizeSpeech(text);\r\n * monitor.measure('tts-synthesis', 'tts-synthesis-start');\r\n * \r\n * // Get metrics\r\n * const metrics = monitor.getMetrics();\r\n * console.log(`Memory usage: ${metrics.memory.percentUsed}%`);\r\n * ```\r\n */\r\n\r\nimport type { IPerformanceMetrics, IMemoryMetrics } from '@/types/global';\r\nimport { createLogger } from './Logger';\r\n\r\nconst logger = createLogger('PerformanceMonitor');\r\n\r\n/**\r\n * Performance monitoring configuration.\r\n */\r\ninterface IPerformanceConfig {\r\n  readonly enabled: boolean;\r\n  readonly sampleInterval: number;\r\n  readonly memoryThreshold: number;\r\n  readonly alertCallback?: (alert: IPerformanceAlert) => void;\r\n}\r\n\r\n/**\r\n * Performance alert information.\r\n */\r\nexport interface IPerformanceAlert {\r\n  readonly type: 'memory' | 'cpu' | 'fps';\r\n  readonly severity: 'warning' | 'critical';\r\n  readonly value: number;\r\n  readonly threshold: number;\r\n  readonly timestamp: number;\r\n  readonly message: string;\r\n}\r\n\r\n/**\r\n * Performance measurement record.\r\n */\r\ninterface IPerformanceMeasurement {\r\n  readonly name: string;\r\n  readonly duration: number;\r\n  readonly startTime: number;\r\n  readonly endTime: number;\r\n}\r\n\r\n/**\r\n * Default configuration.\r\n */\r\nconst DEFAULT_CONFIG: IPerformanceConfig = {\r\n  enabled: __DEV__ || true, // Always enabled for production monitoring\r\n  sampleInterval: 5000, // 5 seconds\r\n  memoryThreshold: 0.85, // 85% of heap limit\r\n} as const;\r\n\r\n/**\r\n * Performance monitor singleton for resource tracking.\r\n */\r\nexport class PerformanceMonitor {\r\n  private static instance: PerformanceMonitor | null = null;\r\n  \r\n  private config: IPerformanceConfig;\r\n  private metricsHistory: IPerformanceMetrics[] = [];\r\n  private measurements: IPerformanceMeasurement[] = [];\r\n  private marks = new Map<string, number>();\r\n  private intervalId: number | null = null;\r\n\r\n  /**\r\n   * Private constructor to enforce singleton pattern.\r\n   * \r\n   * @param config - Optional configuration overrides\r\n   */\r\n  private constructor(config: Partial<IPerformanceConfig> = {}) {\r\n    this.config = { ...DEFAULT_CONFIG, ...config };\r\n    \r\n    if (this.config.enabled) {\r\n      this.startMonitoring();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the singleton instance.\r\n   * \r\n   * @param config - Optional configuration for first initialization\r\n   * @returns PerformanceMonitor instance\r\n   */\r\n  public static getInstance(config?: Partial<IPerformanceConfig>): PerformanceMonitor {\r\n    if (PerformanceMonitor.instance === null) {\r\n      PerformanceMonitor.instance = new PerformanceMonitor(config);\r\n    }\r\n    return PerformanceMonitor.instance;\r\n  }\r\n\r\n  /**\r\n   * Creates a performance mark at the current time.\r\n   * \r\n   * @param name - Mark name\r\n   * \r\n   * @example\r\n   * ```typescript\r\n   * monitor.mark('operation-start');\r\n   * // ... do work ...\r\n   * monitor.measure('operation', 'operation-start');\r\n   * ```\r\n   */\r\n  public mark(name: string): void {\r\n    if (!this.config.enabled) {\r\n      return;\r\n    }\r\n\r\n    this.marks.set(name, performance.now());\r\n    \r\n    // Also use native Performance API if available\r\n    if (typeof performance.mark === 'function') {\r\n      performance.mark(name);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Measures duration between two marks or from a mark to now.\r\n   * \r\n   * @param name - Measurement name\r\n   * @param startMark - Start mark name\r\n   * @param endMark - Optional end mark name (defaults to now)\r\n   * @returns Measurement duration in milliseconds\r\n   * \r\n   * @throws {Error} If start mark doesn't exist\r\n   */\r\n  public measure(name: string, startMark: string, endMark?: string): number {\r\n    if (!this.config.enabled) {\r\n      return 0;\r\n    }\r\n\r\n    const startTime = this.marks.get(startMark);\r\n    if (startTime === undefined) {\r\n      throw new Error(`Performance mark \"${startMark}\" not found`);\r\n    }\r\n\r\n    const endTime = endMark !== undefined\r\n      ? this.marks.get(endMark)\r\n      : performance.now();\r\n\r\n    if (endTime === undefined) {\r\n      throw new Error(`Performance mark \"${endMark}\" not found`);\r\n    }\r\n\r\n    const duration = endTime - startTime;\r\n\r\n    const measurement: IPerformanceMeasurement = {\r\n      name,\r\n      duration,\r\n      startTime,\r\n      endTime,\r\n    };\r\n\r\n    this.measurements.push(measurement);\r\n\r\n    // Keep only last 100 measurements\r\n    if (this.measurements.length > 100) {\r\n      this.measurements.shift();\r\n    }\r\n\r\n    logger.debug(`Performance: ${name} took ${duration.toFixed(2)}ms`);\r\n\r\n    return duration;\r\n  }\r\n\r\n  /**\r\n   * Gets current performance metrics snapshot.\r\n   * \r\n   * @returns Current performance metrics\r\n   */\r\n  public getMetrics(): IPerformanceMetrics {\r\n    return {\r\n      timestamp: Date.now(),\r\n      memory: this.getMemoryMetrics(),\r\n      cpu: this.getCPUMetrics(),\r\n      network: this.getNetworkMetrics(),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Gets memory usage metrics.\r\n   * \r\n   * @returns Memory metrics\r\n   */\r\n  public getMemoryMetrics(): IMemoryMetrics {\r\n    const memory = performance.memory;\r\n\r\n    if (memory === undefined) {\r\n      // Fallback if memory API not available\r\n      return {\r\n        usedJSHeapSize: 0,\r\n        totalJSHeapSize: 0,\r\n        jsHeapSizeLimit: 0,\r\n        percentUsed: 0,\r\n      };\r\n    }\r\n\r\n    const percentUsed = memory.jsHeapSizeLimit > 0\r\n      ? (memory.usedJSHeapSize / memory.jsHeapSizeLimit) * 100\r\n      : 0;\r\n\r\n    return {\r\n      usedJSHeapSize: memory.usedJSHeapSize,\r\n      totalJSHeapSize: memory.totalJSHeapSize,\r\n      jsHeapSizeLimit: memory.jsHeapSizeLimit,\r\n      percentUsed,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Gets CPU usage estimation.\r\n   * Based on frame timing and task duration.\r\n   * \r\n   * @returns CPU metrics\r\n   */\r\n  private getCPUMetrics(): { usage: number; throttled: boolean } {\r\n    // Estimate CPU usage from frame timing\r\n    // This is a simplified heuristic\r\n    const entries = performance.getEntriesByType('measure');\r\n    \r\n    if (entries.length === 0) {\r\n      return { usage: 0, throttled: false };\r\n    }\r\n\r\n    // Calculate average task duration\r\n    const avgDuration = entries.reduce((sum, entry) => sum + entry.duration, 0) / entries.length;\r\n    \r\n    // Rough estimate: usage percentage based on 60fps budget (16.67ms per frame)\r\n    const frameBudget = 16.67;\r\n    const usage = Math.min((avgDuration / frameBudget) * 100, 100);\r\n    const throttled = usage > 80;\r\n\r\n    return { usage, throttled };\r\n  }\r\n\r\n  /**\r\n   * Gets network metrics.\r\n   * \r\n   * @returns Network metrics\r\n   */\r\n  private getNetworkMetrics(): {\r\n    online: boolean;\r\n    effectiveType: string;\r\n    downlink: number;\r\n    rtt: number;\r\n  } {\r\n    const connection = (navigator as unknown as {\r\n      connection?: {\r\n        effectiveType: string;\r\n        downlink: number;\r\n        rtt: number;\r\n      };\r\n    }).connection;\r\n\r\n    return {\r\n      online: navigator.onLine,\r\n      effectiveType: connection?.effectiveType ?? 'unknown',\r\n      downlink: connection?.downlink ?? 0,\r\n      rtt: connection?.rtt ?? 0,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Gets all performance measurements.\r\n   * \r\n   * @returns Array of measurements\r\n   */\r\n  public getMeasurements(): readonly IPerformanceMeasurement[] {\r\n    return Object.freeze([...this.measurements]);\r\n  }\r\n\r\n  /**\r\n   * Gets measurements by name.\r\n   * \r\n   * @param name - Measurement name to filter by\r\n   * @returns Filtered measurements\r\n   */\r\n  public getMeasurementsByName(name: string): readonly IPerformanceMeasurement[] {\r\n    return Object.freeze(\r\n      this.measurements.filter((m) => m.name === name)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Gets average duration for named measurements.\r\n   * \r\n   * @param name - Measurement name\r\n   * @returns Average duration in milliseconds\r\n   */\r\n  public getAverageDuration(name: string): number {\r\n    const measurements = this.getMeasurementsByName(name);\r\n    \r\n    if (measurements.length === 0) {\r\n      return 0;\r\n    }\r\n\r\n    const sum = measurements.reduce((acc, m) => acc + m.duration, 0);\r\n    return sum / measurements.length;\r\n  }\r\n\r\n  /**\r\n   * Clears all marks and measurements.\r\n   */\r\n  public clear(): void {\r\n    this.marks.clear();\r\n    this.measurements.length = 0;\r\n    \r\n    if (typeof performance.clearMarks === 'function') {\r\n      performance.clearMarks();\r\n    }\r\n    if (typeof performance.clearMeasures === 'function') {\r\n      performance.clearMeasures();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clears specific mark.\r\n   * \r\n   * @param name - Mark name to clear\r\n   */\r\n  public clearMark(name: string): void {\r\n    this.marks.delete(name);\r\n    \r\n    if (typeof performance.clearMarks === 'function') {\r\n      performance.clearMarks(name);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Starts periodic monitoring.\r\n   */\r\n  private startMonitoring(): void {\r\n    if (this.intervalId !== null) {\r\n      return;\r\n    }\r\n\r\n    // Initial snapshot\r\n    this.captureMetrics();\r\n\r\n    // Periodic snapshots\r\n    this.intervalId = window.setInterval(() => {\r\n      this.captureMetrics();\r\n    }, this.config.sampleInterval);\r\n\r\n    logger.info('Performance monitoring started', {\r\n      interval: this.config.sampleInterval,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Stops periodic monitoring.\r\n   */\r\n  public stopMonitoring(): void {\r\n    if (this.intervalId !== null) {\r\n      clearInterval(this.intervalId);\r\n      this.intervalId = null;\r\n      logger.info('Performance monitoring stopped');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Captures current metrics snapshot.\r\n   */\r\n  private captureMetrics(): void {\r\n    const metrics = this.getMetrics();\r\n    \r\n    this.metricsHistory.push(metrics);\r\n\r\n    // Keep only last hour of data (assuming 5s interval = 720 samples/hour)\r\n    if (this.metricsHistory.length > 720) {\r\n      this.metricsHistory.shift();\r\n    }\r\n\r\n    // Check thresholds and trigger alerts\r\n    this.checkThresholds(metrics);\r\n  }\r\n\r\n  /**\r\n   * Checks performance thresholds and triggers alerts.\r\n   * \r\n   * @param metrics - Current metrics\r\n   */\r\n  private checkThresholds(metrics: IPerformanceMetrics): void {\r\n    // Memory threshold check\r\n    const memoryPercent = metrics.memory.percentUsed / 100;\r\n    \r\n    if (memoryPercent >= this.config.memoryThreshold) {\r\n      const alert: IPerformanceAlert = {\r\n        type: 'memory',\r\n        severity: memoryPercent >= 0.95 ? 'critical' : 'warning',\r\n        value: memoryPercent * 100,\r\n        threshold: this.config.memoryThreshold * 100,\r\n        timestamp: Date.now(),\r\n        message: `Memory usage at ${(memoryPercent * 100).toFixed(1)}% (threshold: ${(this.config.memoryThreshold * 100).toFixed(0)}%)`,\r\n      };\r\n\r\n      this.triggerAlert(alert);\r\n    }\r\n\r\n    // CPU threshold check\r\n    if (metrics.cpu.usage > 80) {\r\n      const alert: IPerformanceAlert = {\r\n        type: 'cpu',\r\n        severity: metrics.cpu.usage > 90 ? 'critical' : 'warning',\r\n        value: metrics.cpu.usage,\r\n        threshold: 80,\r\n        timestamp: Date.now(),\r\n        message: `CPU usage at ${metrics.cpu.usage.toFixed(1)}%`,\r\n      };\r\n\r\n      this.triggerAlert(alert);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Triggers performance alert.\r\n   * \r\n   * @param alert - Alert information\r\n   */\r\n  private triggerAlert(alert: IPerformanceAlert): void {\r\n    logger.warn(`Performance alert: ${alert.message}`, {\r\n      type: alert.type,\r\n      severity: alert.severity,\r\n      value: alert.value,\r\n      threshold: alert.threshold,\r\n    });\r\n\r\n    if (this.config.alertCallback !== undefined) {\r\n      this.config.alertCallback(alert);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets metrics history.\r\n   * \r\n   * @param limit - Maximum number of entries to return\r\n   * @returns Metrics history\r\n   */\r\n  public getMetricsHistory(limit?: number): readonly IPerformanceMetrics[] {\r\n    const history = [...this.metricsHistory].reverse();\r\n    return Object.freeze(\r\n      limit !== undefined ? history.slice(0, limit) : history\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Generates performance report.\r\n   * \r\n   * @returns Formatted performance report\r\n   */\r\n  public generateReport(): string {\r\n    const currentMetrics = this.getMetrics();\r\n    const measurements = this.getMeasurements();\r\n\r\n    let report = '=== Performance Report ===\\n\\n';\r\n\r\n    // Memory stats\r\n    report += '--- Memory ---\\n';\r\n    report += `Used: ${(currentMetrics.memory.usedJSHeapSize / 1024 / 1024).toFixed(2)} MB\\n`;\r\n    report += `Total: ${(currentMetrics.memory.totalJSHeapSize / 1024 / 1024).toFixed(2)} MB\\n`;\r\n    report += `Limit: ${(currentMetrics.memory.jsHeapSizeLimit / 1024 / 1024).toFixed(2)} MB\\n`;\r\n    report += `Usage: ${currentMetrics.memory.percentUsed.toFixed(1)}%\\n\\n`;\r\n\r\n    // CPU stats\r\n    report += '--- CPU ---\\n';\r\n    report += `Usage: ${currentMetrics.cpu.usage.toFixed(1)}%\\n`;\r\n    report += `Throttled: ${currentMetrics.cpu.throttled ? 'Yes' : 'No'}\\n\\n`;\r\n\r\n    // Network stats\r\n    report += '--- Network ---\\n';\r\n    report += `Status: ${currentMetrics.network.online ? 'Online' : 'Offline'}\\n`;\r\n    report += `Type: ${currentMetrics.network.effectiveType}\\n`;\r\n    report += `Downlink: ${currentMetrics.network.downlink} Mbps\\n`;\r\n    report += `RTT: ${currentMetrics.network.rtt} ms\\n\\n`;\r\n\r\n    // Top 10 slowest operations\r\n    if (measurements.length > 0) {\r\n      report += '--- Top 10 Slowest Operations ---\\n';\r\n      const sorted = [...measurements].sort((a, b) => b.duration - a.duration);\r\n      sorted.slice(0, 10).forEach((m, i) => {\r\n        report += `${i + 1}. ${m.name}: ${m.duration.toFixed(2)}ms\\n`;\r\n      });\r\n    }\r\n\r\n    return report;\r\n  }\r\n}\r\n\r\n/**\r\n * Global performance monitor instance.\r\n */\r\nexport const performanceMonitor = PerformanceMonitor.getInstance();","/**\n * Abstract TTS service interface + Factory\n */\n\nimport type {\n  ITTSRequest,\n  ITTSResult,\n  ITTSError,\n  ITTSStatus,\n  IVoiceModel,\n} from '@/js/types/global';\nimport { createLogger } from '@/js/util/Logger';\nimport { errorHandler } from '@/js/util/ErrorHandler';\nimport { performanceMonitor } from '@/js/util/PerformanceMonitor';\n\nconst logger = createLogger('TTSService');\n\nexport interface ITTSSynthesizeOptions {\n  readonly text: string;\n  readonly voice?: string;\n  readonly rate?: number;\n  readonly pitch?: number;\n  readonly volume?: number;\n  readonly language?: string;\n}\n\nexport interface ITTSPlaybackOptions {\n  readonly loop?: boolean;\n  readonly volume?: number;\n  readonly onEnd?: () => void;\n  readonly onError?: (error: Error) => void;\n}\n\nexport abstract class TTSService {\n  protected isInitialized = false;\n  protected currentVoice: string | null = null;\n  protected audioContext: AudioContext | null = null;\n  \n  public abstract initialize(): Promise<void>;\n  public abstract synthesize(options: ITTSSynthesizeOptions): Promise<ITTSResult>;\n  public abstract getAvailableVoices(): Promise<readonly IVoiceModel[]>;\n  public abstract getStatus(): ITTSStatus;\n  public abstract cleanup(): Promise<void>;\n\n  public async play(\n    result: ITTSResult,\n    options: ITTSPlaybackOptions = {}\n  ): Promise<void> {\n    performanceMonitor.mark('tts-playback-start');\n\n    try {\n      if (this.audioContext === null) {\n        this.audioContext = new AudioContext();\n      }\n\n      if (this.audioContext.state === 'suspended') {\n        await this.audioContext.resume();\n      }\n\n      const audioBuffer = await this.audioContext.decodeAudioData(\n        result.audioData.slice(0)\n      );\n\n      const source = this.audioContext.createBufferSource();\n      source.buffer = audioBuffer;\n      source.loop = options.loop ?? false;\n\n      const gainNode = this.audioContext.createGain();\n      gainNode.gain.value = options.volume ?? 1.0;\n\n      source.connect(gainNode);\n      gainNode.connect(this.audioContext.destination);\n\n      return new Promise<void>((resolve, reject) => {\n        source.onended = () => {\n          source.disconnect();\n          gainNode.disconnect();\n          \n          if (options.onEnd !== undefined) {\n            options.onEnd();\n          }\n          \n          performanceMonitor.measure('tts-playback', 'tts-playback-start');\n          resolve();\n        };\n\n        const errorCallback = (error: Error): void => {\n          source.disconnect();\n          gainNode.disconnect();\n          \n          if (options.onError !== undefined) {\n            options.onError(error);\n          }\n          \n          reject(error);\n        };\n\n        try {\n          source.start(0);\n        } catch (error) {\n          errorCallback(error instanceof Error ? error : new Error(String(error)));\n        }\n      });\n    } catch (error) {\n      const handledError = errorHandler.handleError(error, {\n        context: 'TTSService.play',\n        severity: 'MEDIUM' as const,\n      });\n      \n      throw new Error(handledError.message);\n    }\n  }\n\n  public stop(): void {\n    if (this.audioContext !== null) {\n      void this.audioContext.close().then(() => {\n        this.audioContext = null;\n      });\n    }\n  }\n\n  public async setVoice(voiceId: string): Promise<void> {\n    const voices = await this.getAvailableVoices();\n    const voice = voices.find((v) => v.id === voiceId);\n\n    if (voice === undefined) {\n      throw new Error(`Voice not found: ${voiceId}`);\n    }\n\n    this.currentVoice = voiceId;\n    logger.info(`Voice changed to: ${voiceId}`);\n  }\n\n  public getCurrentVoice(): string | null {\n    return this.currentVoice;\n  }\n\n  protected validateOptions(\n    options: ITTSSynthesizeOptions\n  ): Required<ITTSSynthesizeOptions> {\n    if (options.text.trim().length === 0) {\n      throw new Error('Text cannot be empty');\n    }\n\n    if (options.text.length > 5000) {\n      throw new Error('Text too long (max 5000 characters)');\n    }\n\n    return {\n      text: options.text,\n      voice: options.voice ?? this.currentVoice ?? 'default',\n      rate: this.clamp(options.rate ?? 1.0, 0.5, 2.0),\n      pitch: this.clamp(options.pitch ?? 1.0, 0.5, 2.0),\n      volume: this.clamp(options.volume ?? 1.0, 0.0, 1.0),\n      language: options.language ?? 'ru-RU',\n    };\n  }\n\n  protected clamp(value: number, min: number, max: number): number {\n    return Math.max(min, Math.min(max, value));\n  }\n\n  protected generateRequestId(): string {\n    return `tts_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n  }\n\n  protected ensureInitialized(): void {\n    if (!this.isInitialized) {\n      throw new Error('TTS service not initialized. Call initialize() first.');\n    }\n  }\n}\n\n/**\n * TTS Factory - выбирает реализацию\n */\nexport class TTSServiceFactory {\n  private static instance: TTSService | null = null;\n\n  public static async getInstance(): Promise<TTSService> {\n    if (TTSServiceFactory.instance === null) {\n      TTSServiceFactory.instance = await TTSServiceFactory.createInstance();\n    }\n    return TTSServiceFactory.instance;\n  }\n\n  private static async createInstance(): Promise<TTSService> {\n    logger.info('Creating TTS service instance...');\n\n    try {\n      // Пробуем ServerTTSService\n      const { ServerTTSService } = await import('./ServerTTSService');\n      const service = new ServerTTSService();\n      await service.initialize();\n      \n      logger.info('TTS service initialized: ServerTTSService');\n      return service;\n    } catch (error) {\n      logger.warn('ServerTTS unavailable, falling back to Mock', error);\n      \n      // Fallback на Mock\n      const { MockTTSService } = await import('./MockTTSService');\n      const service = new MockTTSService();\n      await service.initialize();\n      \n      logger.info('TTS service initialized: MockTTSService (fallback)');\n      return service;\n    }\n  }\n\n  public static reset(): void {\n    if (TTSServiceFactory.instance !== null) {\n      void TTSServiceFactory.instance.cleanup();\n      TTSServiceFactory.instance = null;\n    }\n  }\n}\n","/**\n * API клиент для AAC NLP сервера.\n * \n * Обрабатывает:\n * - Построение предложений из слов\n * - Генерацию речи\n * - Кеширование ответов\n * - Обработку ошибок и retry\n */\n\nimport { errorHandler } from '@/js/util/ErrorHandler';\nimport { createLogger } from '@/js/util/Logger';\nimport { performanceMonitor } from '@/js/util/PerformanceMonitor';\n\nconst logger = createLogger('NLPClient');\n\n/**\n * Конфигурация API.\n */\ninterface INLPConfig {\n  readonly serverUrl: string;\n  readonly timeout: number;\n  readonly retryAttempts: number;\n}\n\n/**\n * Результат построения предложения.\n */\nexport interface ISentenceResult {\n  readonly sentence: string;\n  readonly originalWords: readonly string[];\n}\n\n/**\n * Клиент для AAC NLP сервера.\n */\n\nexport class NLPClient {\n  private static instance: NLPClient | null = null;\n\n  private readonly config: INLPConfig = {\n    serverUrl: 'http://192.168.0.104:5000',  // Твой IP с сервером TTS\n    timeout: 5000,  // Уменьшил таймаут для быстрой обработки ошибок\n    retryAttempts: 1,  // Меньше retry - быстрее fallback на mock\n  };\n\n  private constructor() {\n    logger.info('NLP Client initialized', { serverUrl: this.config.serverUrl });\n  }\n\n  /**\n   * Получить singleton instance.\n   */\n  public static getInstance(): NLPClient {\n    if (NLPClient.instance === null) {\n      NLPClient.instance = new NLPClient();\n    }\n    return NLPClient.instance;\n  }\n\n  /**\n   * Проверка здоровья сервера.\n   * \n   * @returns Promise с статусом сервера\n   */\n  public async healthCheck(): Promise<{ status: string; model: string }> {\n    performanceMonitor.mark('nlp-health-check-start');\n\n    try {\n      const response = await fetch(`${this.config.serverUrl}/health`, {\n        method: 'GET',\n        signal: AbortSignal.timeout(this.config.timeout),\n      });\n\n      if (!response.ok) {\n        throw new Error(`Server returned ${response.status}`);\n      }\n\n      const data = await response.json();\n\n      performanceMonitor.measure('nlp-health-check', 'nlp-health-check-start');\n\n      return data;\n    } catch (error) {\n      logger.error('Health check failed', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Построить предложение из слов.\n   * \n   * @param words - Массив слов\n   * @returns Promise с предложением\n   */\n  public async buildSentence(words: readonly string[]): Promise<ISentenceResult> {\n    performanceMonitor.mark('nlp-sentence-start');\n\n    try {\n      const response = await errorHandler.withRetry(\n        async () => {\n          const res = await fetch(`${this.config.serverUrl}/api/sentence`, {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({ words }),\n            signal: AbortSignal.timeout(this.config.timeout),\n          });\n\n          if (!res.ok) {\n            throw new Error(`Server returned ${res.status}`);\n          }\n\n          return res.json();\n        },\n        {\n          maxRetries: this.config.retryAttempts,\n          retryDelay: 1000,\n          context: 'NLPClient.buildSentence',\n        }\n      );\n\n      performanceMonitor.measure('nlp-sentence', 'nlp-sentence-start');\n\n      logger.info('Sentence built', {\n        words: words.length,\n        sentence: response.sentence,\n      });\n\n      return response;\n    } catch (error) {\n      logger.error('Failed to build sentence', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Сгенерировать речь из слов.\n   * \n   * @param words - Массив слов\n   * @returns Promise с аудио данными (ArrayBuffer)\n   */\n  public async generateSpeech(words: readonly string[]): Promise<ArrayBuffer> {\n    performanceMonitor.mark('nlp-speech-start');\n\n    try {\n      const response = await errorHandler.withRetry(\n        async () => {\n          const res = await fetch(`${this.config.serverUrl}/api/speak`, {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({ words }),\n            signal: AbortSignal.timeout(30000), // 30 sec для генерации\n          });\n\n          if (!res.ok) {\n            throw new Error(`Server returned ${res.status}`);\n          }\n\n          return res.arrayBuffer();\n        },\n        {\n          maxRetries: 2,\n          retryDelay: 2000,\n          context: 'NLPClient.generateSpeech',\n        }\n      );\n\n      performanceMonitor.measure('nlp-speech', 'nlp-speech-start');\n\n      logger.info('Speech generated', {\n        words: words.length,\n        audioSize: response.byteLength,\n      });\n\n      return response;\n    } catch (error) {\n      logger.error('Failed to generate speech', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Установить URL сервера.\n   * \n   * @param url - URL сервера\n   */\n  public setServerUrl(url: string): void {\n    (this.config as { serverUrl: string }).serverUrl = url;\n    logger.info('Server URL updated', { url });\n  }\n}\n\n/**\n * Глобальный экземпляр клиента.\n */\nexport const nlpClient = NLPClient.getInstance();\n","/**\n * Тестовая страница для TTS\n */\n\nimport { TTSServiceFactory } from './service/tts/TTSService';\nimport { nlpClient } from './service/api/NLPClient';\nimport { createLogger } from './util/Logger';\n\nconst logger = createLogger('TestTTS');\n\nasync function testTTS(): Promise<void> {\n  const appDiv = document.getElementById('app');\n  if (!appDiv) return;\n\n  appDiv.innerHTML = `\n    <div style=\"padding: 20px; font-family: Arial; max-width: 600px;\">\n      <h1>🎤 TTS Тест</h1>\n      \n      <div style=\"margin: 20px 0;\">\n        <label>IP сервера:</label><br>\n        <input type=\"text\" id=\"serverUrl\" value=\"http://192.168.0.104:5000\" style=\"width: 100%; padding: 8px;\">\n        <button id=\"setServer\" style=\"margin-top: 5px; padding: 8px 16px;\">Установить</button>\n        <button id=\"testServer\" style=\"margin-top: 5px; padding: 8px 16px; background: #4CAF50; color: white; border: none;\">Тест сервера</button>\n      </div>\n      \n      <div style=\"margin: 20px 0;\">\n        <label>Введи слова (через пробел):</label><br>\n        <input type=\"text\" id=\"wordsInput\" value=\"Я обниматься мама папа\" style=\"width: 100%; padding: 8px;\">\n      </div>\n      \n      <button id=\"speakBtn\" style=\"padding: 10px 20px; font-size: 16px; background: #2196F3; color: white; border: none; cursor: pointer;\">\n        🔊 Озвучить\n      </button>\n      \n      <div id=\"status\" style=\"margin-top: 20px; padding: 10px; background: #f0f0f0; border-radius: 4px; white-space: pre-wrap; font-family: monospace; font-size: 12px; max-height: 400px; overflow-y: auto;\">\n        Готов к работе\n      </div>\n      \n      <div id=\"logs\" style=\"margin-top: 20px; padding: 10px; background: #263238; color: #aed581; border-radius: 4px; white-space: pre-wrap; font-family: monospace; font-size: 11px; max-height: 300px; overflow-y: auto;\">\n        === ЛОГИ ===\n      </div>\n    </div>\n  `;\n\n  const serverUrlInput = document.getElementById('serverUrl') as HTMLInputElement;\n  const setServerBtn = document.getElementById('setServer');\n  const testServerBtn = document.getElementById('testServer');\n  const wordsInput = document.getElementById('wordsInput') as HTMLInputElement;\n  const speakBtn = document.getElementById('speakBtn');\n  const statusDiv = document.getElementById('status');\n  const logsDiv = document.getElementById('logs');\n\n  function addLog(msg: string): void {\n    const timestamp = new Date().toLocaleTimeString();\n    if (logsDiv) {\n      logsDiv.textContent += `\\n[${timestamp}] ${msg}`;\n      logsDiv.scrollTop = logsDiv.scrollHeight;\n    }\n    console.log(msg);\n  }\n\n  function updateStatus(msg: string, isError = false): void {\n    if (statusDiv) {\n      statusDiv.textContent = msg;\n      statusDiv.style.background = isError ? '#ffebee' : '#e8f5e9';\n    }\n    addLog(msg);\n  }\n\n  // Добавляем глобальный обработчик ошибок\n  window.addEventListener('error', (e) => {\n    addLog(`🔴 GLOBAL ERROR: ${e.message} at ${e.filename}:${e.lineno}`);\n  });\n\n  window.addEventListener('unhandledrejection', (e) => {\n    addLog(`🔴 UNHANDLED REJECTION: ${e.reason}`);\n  });\n\n  // Установка URL сервера\n  setServerBtn?.addEventListener('click', () => {\n    const url = serverUrlInput.value.trim();\n    nlpClient.setServerUrl(url);\n    updateStatus(`Сервер установлен: ${url}`);\n  });\n\n  // Тест подключения к серверу\n  testServerBtn?.addEventListener('click', async () => {\n    const url = serverUrlInput.value.trim();\n    addLog(`🔍 Тестирую подключение к ${url}...`);\n    \n    try {\n      updateStatus('Проверка /health...');\n      const response = await fetch(`${url}/health`, {\n        method: 'GET',\n        signal: AbortSignal.timeout(5000),\n      });\n      \n      addLog(`📡 Статус ответа: ${response.status} ${response.statusText}`);\n      \n      if (!response.ok) {\n        updateStatus(`❌ Сервер вернул ${response.status}`, true);\n        return;\n      }\n      \n      const data = await response.json();\n      addLog(`✅ Ответ сервера: ${JSON.stringify(data, null, 2)}`);\n      updateStatus(`✅ Сервер работает! Model: ${data.model || 'unknown'}`);\n      \n    } catch (error) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      addLog(`❌ Ошибка подключения: ${err.name} - ${err.message}`);\n      addLog(`Stack: ${err.stack}`);\n      updateStatus(`❌ Не могу подключиться: ${err.message}`, true);\n    }\n  });\n\n  // Озвучивание\n  speakBtn?.addEventListener('click', async () => {\n    try {\n      addLog('🎤 Начинаю озвучивание...');\n      updateStatus('Инициализация TTS...');\n      \n      addLog('📦 Создаю TTS сервис...');\n      const tts = await TTSServiceFactory.getInstance();\n      addLog('✅ TTS сервис создан');\n      \n      const text = wordsInput.value.trim();\n      const words = text.split(/\\s+/).filter(w => w.length > 0);\n      \n      addLog(`📝 Слова для озвучки: ${words.join(', ')}`);\n      updateStatus(`Генерация речи для: ${words.join(', ')}...`);\n      \n      addLog('🔊 Синтезирую речь...');\n      const result = await tts.synthesize({ text });\n      addLog(`✅ Речь синтезирована. Размер: ${result.audioData.byteLength} bytes`);\n      \n      updateStatus('Воспроизведение...');\n      \n      await tts.play(result, {\n        onEnd: () => {\n          addLog('✅ Воспроизведение завершено');\n          updateStatus('✅ Готово!');\n        },\n        onError: (err) => {\n          addLog(`❌ Ошибка воспроизведения: ${err.message}`);\n          updateStatus(`❌ Ошибка: ${err.message}`, true);\n        },\n      });\n      \n    } catch (error) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error('Test failed', err);\n      addLog(`❌ КРИТИЧЕСКАЯ ОШИБКА: ${err.name} - ${err.message}`);\n      addLog(`Stack: ${err.stack}`);\n      updateStatus(`❌ Ошибка: ${err.message}`, true);\n    }\n  });\n\n  // Логируем старт приложения\n  addLog('🚀 Приложение запущено');\n  addLog(`📱 UserAgent: ${navigator.userAgent}`);\n  addLog(`🌐 URL: ${window.location.href}`);\n  addLog(`🔌 Сервер по умолчанию: http://192.168.0.104:5000`);\n}\n\n// Запуск при загрузке\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', () => void testTTS());\n} else {\n  void testTTS();\n}\n"],"file":"assets/js/index.Ba1ewq7F.js"}