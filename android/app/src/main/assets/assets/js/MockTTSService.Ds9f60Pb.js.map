{"version":3,"file":"MockTTSService.Ds9f60Pb.js","sources":["../../../src/js/service/tts/MockTTSService.ts"],"sourcesContent":["/**\r\n * Mock TTS service for development and testing.\r\n * \r\n * Uses Web Speech API as fallback while Piper TTS is being integrated.\r\n * This implementation will be replaced by PiperTTSService in Phase 2.\r\n * \r\n * Features:\r\n * - Web Speech API integration\r\n * - Simulated async behavior for testing\r\n * - Memory-safe audio generation\r\n * - Performance metrics collection\r\n * \r\n * @example\r\n * ```typescript\r\n * const tts = new MockTTSService();\r\n * await tts.initialize();\r\n * const result = await tts.synthesize({ text: 'Hello world' });\r\n * await tts.play(result);\r\n * ```\r\n */\r\n\r\nimport {\r\n  TTSService,\r\n  type ITTSSynthesizeOptions,\r\n} from './TTSService';\r\nimport type {\r\n  ITTSResult,\r\n  ITTSStatus,\r\n  IVoiceModel,\r\n  ITTSError,\r\n} from '@/js/types/global';\r\nimport { createLogger } from '@/js/util/Logger';\r\nimport { performanceMonitor } from '@/js/util/PerformanceMonitor';\r\n\r\nconst logger = createLogger('MockTTSService');\r\n\r\n/**\r\n * Mock TTS service using Web Speech API.\r\n * Development/testing implementation.\r\n */\r\nexport class MockTTSService extends TTSService {\r\n  private synth: SpeechSynthesis | null = null;\r\n  private availableVoices: IVoiceModel[] = [];\r\n  private activeRequests = 0;\r\n  private queuedRequests = 0;\r\n\r\n  /**\r\n   * Initializes mock TTS service.\r\n   * \r\n   * @throws {Error} If Web Speech API not available\r\n   */\r\n  public async initialize(): Promise<void> {\r\n    performanceMonitor.mark('tts-init-start');\r\n\r\n    try {\r\n      // Check for Web Speech API support\r\n      if (!('speechSynthesis' in window)) {\r\n        throw new Error('Web Speech API not supported in this browser');\r\n      }\r\n\r\n      this.synth = window.speechSynthesis;\r\n\r\n      // Load available voices\r\n      await this.loadVoices();\r\n\r\n      this.isInitialized = true;\r\n\r\n      performanceMonitor.measure('tts-init', 'tts-init-start');\r\n      logger.info('Mock TTS service initialized', {\r\n        voiceCount: this.availableVoices.length,\r\n      });\r\n    } catch (error) {\r\n      logger.error('Failed to initialize Mock TTS service', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Synthesizes text to speech using Web Speech API.\r\n   * \r\n   * Note: Web Speech API doesn't return raw audio data,\r\n   * so we generate a mock audio buffer for consistency with the interface.\r\n   * \r\n   * @param options - Synthesis options\r\n   * @returns Promise resolving to synthesis result\r\n   */\r\n  public async synthesize(options: ITTSSynthesizeOptions): Promise<ITTSResult> {\r\n    this.ensureInitialized();\r\n\r\n    const requestId = this.generateRequestId();\r\n    performanceMonitor.mark(`tts-synthesis-start-${requestId}`);\r\n\r\n    this.activeRequests++;\r\n\r\n    try {\r\n      const validatedOptions = this.validateOptions(options);\r\n\r\n      logger.debug('Synthesizing text', {\r\n        requestId,\r\n        textLength: validatedOptions.text.length,\r\n        voice: validatedOptions.voice,\r\n      });\r\n\r\n      // Generate mock audio buffer\r\n      // In real Piper TTS implementation, this will be actual synthesized audio\r\n      const audioData = await this.generateMockAudio(validatedOptions);\r\n\r\n      const synthesisTime = performanceMonitor.measure(\r\n        `tts-synthesis-${requestId}`,\r\n        `tts-synthesis-start-${requestId}`\r\n      );\r\n\r\n      const result: ITTSResult = {\r\n        requestId,\r\n        audioData,\r\n        duration: this.estimateDuration(validatedOptions.text),\r\n        sampleRate: 22050, // Typical TTS sample rate\r\n        channels: 1, // Mono\r\n        synthesisTime,\r\n      };\r\n\r\n      logger.info('Synthesis completed', {\r\n        requestId,\r\n        duration: result.duration,\r\n        synthesisTime: result.synthesisTime,\r\n      });\r\n\r\n      return result;\r\n    } catch (error) {\r\n      logger.error('Synthesis failed', error);\r\n      \r\n      const ttsError: ITTSError = {\r\n        code: 'SYNTHESIS_FAILED',\r\n        message: error instanceof Error ? error.message : String(error),\r\n        requestId,\r\n        timestamp: Date.now(),\r\n        details: error,\r\n      };\r\n\r\n      throw ttsError;\r\n    } finally {\r\n      this.activeRequests--;\r\n      performanceMonitor.clearMark(`tts-synthesis-start-${requestId}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets available voice models.\r\n   * \r\n   * @returns Array of available voice models\r\n   */\r\n  public async getAvailableVoices(): Promise<readonly IVoiceModel[]> {\r\n    this.ensureInitialized();\r\n\r\n    if (this.availableVoices.length === 0) {\r\n      await this.loadVoices();\r\n    }\r\n\r\n    return Object.freeze([...this.availableVoices]);\r\n  }\r\n\r\n  /**\r\n   * Gets current service status.\r\n   * \r\n   * @returns Service status\r\n   */\r\n  public getStatus(): ITTSStatus {\r\n    return {\r\n      initialized: this.isInitialized,\r\n      activeRequests: this.activeRequests,\r\n      queuedRequests: this.queuedRequests,\r\n      availableVoices: this.availableVoices.map((v) => v.id),\r\n      memoryUsage: this.estimateMemoryUsage(),\r\n      lastError: null,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Cleans up resources.\r\n   */\r\n  public async cleanup(): Promise<void> {\r\n    if (this.synth !== null) {\r\n      this.synth.cancel();\r\n      this.synth = null;\r\n    }\r\n\r\n    this.stop();\r\n    this.isInitialized = false;\r\n    this.availableVoices = [];\r\n\r\n    logger.info('Mock TTS service cleaned up');\r\n  }\r\n\r\n  /**\r\n   * Loads available voices from Web Speech API.\r\n   * \r\n   * @returns Promise that resolves when voices are loaded\r\n   */\r\n  private loadVoices(): Promise<void> {\r\n    return new Promise((resolve) => {\r\n      if (this.synth === null) {\r\n        resolve();\r\n        return;\r\n      }\r\n\r\n      const loadVoicesImpl = (): void => {\r\n        const voices = this.synth!.getVoices();\r\n        \r\n        this.availableVoices = voices.map((voice, index) => ({\r\n          id: `mock_${index}`,\r\n          name: voice.name,\r\n          language: voice.lang,\r\n          gender: this.guessGender(voice.name),\r\n          sampleRate: 22050,\r\n          modelSize: 0, // Mock - no actual model\r\n          quality: 'medium',\r\n          loaded: true,\r\n        }));\r\n\r\n        // Set default voice if not set\r\n        if (this.currentVoice === null && this.availableVoices.length > 0) {\r\n          const englishVoice = this.availableVoices.find((v) =>\r\n            v.language.startsWith('en')\r\n          );\r\n          this.currentVoice = englishVoice?.id ?? this.availableVoices[0]!.id;\r\n        }\r\n\r\n        resolve();\r\n      };\r\n\r\n      // Some browsers load voices asynchronously\r\n      if (this.synth.getVoices().length > 0) {\r\n        loadVoicesImpl();\r\n      } else {\r\n        this.synth.onvoiceschanged = () => {\r\n          loadVoicesImpl();\r\n        };\r\n\r\n        // Fallback timeout\r\n        setTimeout(() => {\r\n          if (this.availableVoices.length === 0) {\r\n            loadVoicesImpl();\r\n          }\r\n        }, 1000);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Generates mock audio buffer.\r\n   * In real implementation, this will be replaced with actual WASM synthesis.\r\n   * \r\n   * @param options - Synthesis options\r\n   * @returns Promise resolving to audio data\r\n   */\r\n  private async generateMockAudio(\r\n    options: Required<ITTSSynthesizeOptions>\r\n  ): Promise<ArrayBuffer> {\r\n    // Generate a simple sine wave as mock audio\r\n    const sampleRate = 22050;\r\n    const duration = this.estimateDuration(options.text);\r\n    const numSamples = Math.floor(sampleRate * duration);\r\n    \r\n    // Create audio buffer\r\n    const buffer = new Float32Array(numSamples);\r\n    const frequency = 440; // A4 note\r\n    \r\n    for (let i = 0; i < numSamples; i++) {\r\n      buffer[i] = Math.sin((2 * Math.PI * frequency * i) / sampleRate) * 0.3;\r\n    }\r\n\r\n    // Convert to WAV format\r\n    return this.encodeWAV(buffer, sampleRate);\r\n  }\r\n\r\n  /**\r\n   * Encodes Float32Array as WAV file.\r\n   * \r\n   * @param samples - Audio samples\r\n   * @param sampleRate - Sample rate in Hz\r\n   * @returns WAV file as ArrayBuffer\r\n   */\r\n  private encodeWAV(samples: Float32Array, sampleRate: number): ArrayBuffer {\r\n    const buffer = new ArrayBuffer(44 + samples.length * 2);\r\n    const view = new DataView(buffer);\r\n\r\n    // WAV header\r\n    const writeString = (offset: number, string: string): void => {\r\n      for (let i = 0; i < string.length; i++) {\r\n        view.setUint8(offset + i, string.charCodeAt(i));\r\n      }\r\n    };\r\n\r\n    writeString(0, 'RIFF');\r\n    view.setUint32(4, 36 + samples.length * 2, true);\r\n    writeString(8, 'WAVE');\r\n    writeString(12, 'fmt ');\r\n    view.setUint32(16, 16, true);\r\n    view.setUint16(20, 1, true);\r\n    view.setUint16(22, 1, true);\r\n    view.setUint32(24, sampleRate, true);\r\n    view.setUint32(28, sampleRate * 2, true);\r\n    view.setUint16(32, 2, true);\r\n    view.setUint16(34, 16, true);\r\n    writeString(36, 'data');\r\n    view.setUint32(40, samples.length * 2, true);\r\n\r\n    // Audio data\r\n    let offset = 44;\r\n    for (let i = 0; i < samples.length; i++) {\r\n      const s = Math.max(-1, Math.min(1, samples[i]!));\r\n      view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\r\n      offset += 2;\r\n    }\r\n\r\n    return buffer;\r\n  }\r\n\r\n  /**\r\n   * Estimates audio duration based on text length.\r\n   * Rough heuristic: ~150 words per minute.\r\n   * \r\n   * @param text - Input text\r\n   * @returns Estimated duration in seconds\r\n   */\r\n  private estimateDuration(text: string): number {\r\n    const wordsPerMinute = 150;\r\n    const wordCount = text.split(/\\s+/).length;\r\n    return (wordCount / wordsPerMinute) * 60;\r\n  }\r\n\r\n  /**\r\n   * Estimates memory usage of the service.\r\n   * \r\n   * @returns Estimated memory usage in bytes\r\n   */\r\n  private estimateMemoryUsage(): number {\r\n    // Rough estimate based on active operations\r\n    const baseUsage = 1024 * 1024; // 1MB base\r\n    const perRequestUsage = 512 * 1024; // 512KB per active request\r\n    \r\n    return baseUsage + this.activeRequests * perRequestUsage;\r\n  }\r\n\r\n  /**\r\n   * Guesses gender from voice name.\r\n   * Simple heuristic for mock implementation.\r\n   * \r\n   * @param name - Voice name\r\n   * @returns Guessed gender\r\n   */\r\n  private guessGender(name: string): 'male' | 'female' | 'neutral' {\r\n    const lowerName = name.toLowerCase();\r\n    \r\n    if (\r\n      lowerName.includes('female') ||\r\n      lowerName.includes('woman') ||\r\n      lowerName.includes('zira') ||\r\n      lowerName.includes('samantha')\r\n    ) {\r\n      return 'female';\r\n    }\r\n    \r\n    if (\r\n      lowerName.includes('male') ||\r\n      lowerName.includes('man') ||\r\n      lowerName.includes('david') ||\r\n      lowerName.includes('alex')\r\n    ) {\r\n      return 'male';\r\n    }\r\n    \r\n    return 'neutral';\r\n  }\r\n}"],"names":["logger","createLogger","MockTTSService","TTSService","constructor","super","arguments","__publicField","this","initialize","performanceMonitor","mark","window","Error","synth","speechSynthesis","loadVoices","isInitialized","measure","info","voiceCount","availableVoices","length","error","synthesize","options","ensureInitialized","requestId","generateRequestId","activeRequests","validatedOptions","validateOptions","debug","textLength","text","voice","audioData","generateMockAudio","synthesisTime","result","duration","estimateDuration","sampleRate","channels","code","message","String","timestamp","Date","now","details","clearMark","getAvailableVoices","Object","freeze","getStatus","initialized","queuedRequests","map","v","id","memoryUsage","estimateMemoryUsage","lastError","cleanup","cancel","stop","Promise","resolve","loadVoicesImpl","voices","getVoices","index","name","language","lang","gender","guessGender","modelSize","quality","loaded","currentVoice","englishVoice","find","startsWith","onvoiceschanged","setTimeout","numSamples","Math","floor","buffer","Float32Array","i","sin","PI","encodeWAV","samples","ArrayBuffer","view","DataView","writeString","offset","string","setUint8","charCodeAt","setUint32","setUint16","s","max","min","setInt16","split","lowerName","toLowerCase","includes"],"mappings":"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"}